phase2_start_service_processes() called -- currently a NOP
phase3_start_service_processes() called -- currently a NOP
phase4_start_service_processes() called -- currently a NOP
phase5_start_service_processes() called -- currently a NOP
testcase_main(): started
EXPECTATION: testcase_main() creates a single 'victim' process XXp3(), which runs at the same priority as testcase_main().  XXp3() is in an infinite loop, copying the 'count' variable to 'countDuplicate', and otherwise just burning CPU time until 'count' reaches N.  After XXp3() is running, testcase_main() creates high-priority children; each increments 'count' and then tries to zap XXp3().  But testcase_main() won't count the new child as created until XXp3() has chewed up a timeslice, updating the 'duplicate' counter as it does so.  Thus, this testcase will not work properly until you have implemented interrupt-based timeslicing, so that XXp3() can run full-bore and still get interrupted to go back to testcase_main().
testcase_main(): spork creating child i=0 -- a new child will run next
XXp2() 0: getpid()=4
XXp2() 0: zapping XXp3    current count: 1
